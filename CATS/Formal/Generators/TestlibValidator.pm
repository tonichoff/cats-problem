package CATS::Formal::Generators::TestlibValidator;

use strict;
use warnings;

use parent 'CATS::Formal::Generators::TestlibBase';

sub id {
    'testlib_validator';
}

sub generate_description {
    my ($self, $fd) = @_;
    die "ROOT obj expected" if $fd->{type} != CATS::Formal::Constants::FD_TYPES->{ROOT};
    my $input = $fd->find_child('INPUT');
    $self->{params} = {};
    %{$self->{params}} = %{$input->{attributes}};
    if (!exists $self->{params}->{strict}) {
        $self->{params}->{strict} = 1;
    }
    my $obj = $self->generate_obj($input, '', 1);
    $self->{declarations} .= $obj->{declaration};
    $self->{reader} .= $obj->{reader};
}

sub pattern {
    my $self = shift;
    my $stream_name = $self->{stream_name};
    my $strict_mode = $self->{params}->{strict};
    my $strict = $strict_mode  ? 'true' : 'false';
    my $seekeof = $strict_mode ? '' : 'inf.seekEof();';
    return <<"END"
/*
    THIS FILE GENERATED BY CATS-Formal
              DO NOT EDIT!!!
        EDIT DESCRIPTION INSTEAD
*/
#include "testlib.h"

using namespace std;

$self->{type_declarations}
$self->{type_definitions}
$self->{declarations}
$self->{functions}

void read_all(InStream& $stream_name){
$self->{reader}
}

int main(int argc, char** argv){
    if (argc > 1){
        /*
            close up for CATS::Spawner
            it will be here while spawner can't redirect streams
        */
        freopen(argv[1], "r", stdin);
    }
    registerValidation();
    inf.strict = $strict;
    read_all(inf);
    $seekeof
    inf.readEof();
    return 0;
}
END
}

1;
